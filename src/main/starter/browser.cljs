(ns starter.browser
  (:require
   [fireworks.core :refer [??? !? ?> !?>]]
   ;; Require various functions and macros from kushi.core
   [applied-science.js-interop :as j]
   [clojure.string :as string]
   [kushi.core :refer [sx
                       defclass
                       inject!
                       inject-stylesheet
                       add-font-face
                       defkeyframes
                       add-google-font!]]
   [domo.core :as domo]
   [kushi.ui.dom.fune.core :refer [append-fune!]]
   ;; Require your apps shared classes and component namespaces
   [starter.badges :as badges]
   [starter.shared-styles]
   [starter.theme]

   ;; This example uses reagent
   [reagent.core :as r]
   [reagent.dom :as rdom]))



;; Injecting Stylesheets
;; ............................................................................


;; Optional.
;; Using kushi.core/inject-stylesheet to inject a static css file.
;; This stylesheet might be a css reset file, or a third-party style library.
;; This is more of an edge case, as you would typically just do this with a
;; <link> in your index.html. However, if your project uses a clj file to
;; generate the contents of your index's <head> at build time, it may be handy
;; to use this during development to inject new stylesheets without restarting
;; your build.

(inject-stylesheet {:rel "stylesheet"
                    :href "css/my-global-styles.css"})


;; Optional.
;; Using kushi.core/inject-stylesheet to load a google font.
;; The additional "preconnect" hints will improve Google Fonts performance.

(inject-stylesheet
 {:rel          "preconnet"
  :href         "https://fonts.gstatic.com"
  :cross-origin "anonymous"})

(inject-stylesheet
 {:rel  "preconnet"
  :href "https://fonts.googleapis.com"})

(inject-stylesheet
 {:rel  "stylesheet"
  :href "https://fonts.googleapis.com/css2?family=Inter:wght@900&display=swap"})


;; If you want to add Google Fonts, you can also just use
;; `kushi.core/add-google-fonts!`, which will abstract the above pattern
;; (3 separate calls) into one call:

(add-google-font! {:family "Inter"
                   :styles {:normal [400 700]
                            :italic [400 700]}})


;;`kushi.core/add-google-font!` accepts any number of args, each one a single
;; map that represents a font-family and associated weights & styles. You can
;; as many different families as you want in a single go (although be mindful
;; of performance):

(add-google-font! {:family "Playfair Display"
                   :styles {:normal [400 700]
                            :italic [400 700]}}
                  {:family "Lato"
                   :styles {:normal [100 400]}}
                  {:family "Pacifico"
                   :styles {:normal [400]}})




;; Adding webfont resources
;; ............................................................................

;; Optional.
;; Using kushi.core/add-font-face macro to load a local font.
;; This will add an @font-face block to the css code/file generated by kushi.
;; The location of the font file must be a path, relative the location of the
;; generated css file. You could also use a remote url to load a hosted font.

;; In the case of this kushi quickstart demo, we are using FiraCodeRegular for
;; the tooltip text within `starter.bandges/icon-badge-link`.

(add-font-face {:font-family "FiraCodeRegular"
                :font-weight "300"
                :font-style "normal"
                :src ["url(../fonts/FiraCode-Regular.woff)"]})



;; Defining animation keyframes
;; ............................................................................

;; Using kushi.core/defkeyframes macro to define keyframes.
(defkeyframes y-axis-spinner
  [:0% {:transform "rotateY(0deg)"}]
  [:100% {:transform "rotateY(360deg)"}])

(defkeyframes x-axis-spinner
  [:0% {:transform "rotateX(0deg)"}]
  [:100% {:transform "rotateX(360deg)"}])




;; Styling component elements with kushi.core/sx
;; ............................................................................

;; You can use kushi.core/sx to co-locate styles within your components.
;; Media queries, pseudo-classes, pseudo-elements, combo-selectors, and dynamic
;; runtime values are all supported.

;; You can also incorporate your own shared classes (via the kushi.core/defclass
;; macro), as well as the useful defclasses that ship with Kushi.

;; kushi.core/sx is a macro that returns an attribute map.
;; This map contains:
;;   - a class property containing the correct auto-generated, hashed prefixed
;;     classnames.

;;   - If necessary, a style property containing the correct auto-generated css
;;     variable names.

;;   - All the other attributes you specify in your attributes map (supplied as
;;     an optional last arg to sx).

;;   - An optional data-ns attribute to help with browser-based debugging
;;     (see docs: "Using metadata").

;; Using a build hook for the :compile-finish stage (or similar), your css is
;; written to a static file.




;; SOME NOTES ON SYNTAX:

;; You can passed a quoted symbol as the first arg to defclass if you want to
;; give the generated class a specific name.
;; (sx 'myfirstclass :c--red :fs--3rem)

;; A keyword starting with a "." represents a classname that will get attached
;; to the element. Typically you would use this for predefined classes created
;; with defclass, but you can also use it to attache arbritary classes to the
;; element. Kushi ships with a small handful of useful pre-defined defclasses.

;; You can apply classes conditionally like so:
;; (when my-binding :.my-class)
;; (if my-binding :.my-class :.my-other-class)


;; A keyword containing "--" represents a css prop and value pair which is
;; split on the "--".

;; Kushi shorthand notation is optionally available for the most commonly
;; used css-props:
;;
;;     :c--red   => :color--red
;;     :ai--c    => :align-items--center
;;     :ai--e    => :align-items--end
;;     :ta--r    => :text-align--right
;;     :fs--18px => :font-size--18px
;;     :d--b     => :display--block
;;     :d--f     => :display--flex
;;     :bgs--50% => :background-size--50%
;;

;; A partial list of these is available here:
;; https://github.com/kushidesign/kushi#syntax


;; Standard CSS shorthand-values are written like this:
;;
;;     :b--1px:solid:#efefef
;;
;; The above is equivalent to `border: 1px solid #efefef`


;; CSS list-like values are written like this:
;;
;;     :ff--FiraCodeRegular|monospace|sans-serif
;;
;; The above is equivalent to:
;; `font-family: FiraCodeRegular, monospace, sans-serif`


;; Media queries, pseudo-classes, pseudo-elements, and combo selectors can be
;; used like this:
;;
;;     (sx sm:c--red
;;         sm:hover:c--blue
;;         :>a:hover:c--gold
;;         :_a:hover:c--gold)


;; In the example below, because "(" and ")" chars are not valid
;; in keywords, the 2-element tuple syntax is required, with
;; the prop being expressed as a string:
;;     (sx ["nth:child(2):c" :red])


;; You can use runtime variable values with the same tuple syntax.
;;     (sx [:c mycolor])

;; You could also write this as:
;;     (sx {:style {:color mycolor})


;; You can use conditional logic to apply different values base
;; on runtime variables.
;;     (sx [:c (if danger? :red :green)])


;; The tuple syntax is also necessary for css functions and string values.
;;
;; Expressing a value as a css function:
;;     (sx [:transform '(translateY :-100px)])
;;     (sx {:style {:transform '(translateY :-100px)}})
;;
;; When a string is desired, or necessary:
;;     (sx [:before:content "\"*\""])
;;     (sx {:style {:before:content "\"*\""}})



;; Now, some working code...

;; First, we define a subcomponent for the rotating banner headline "layers"
;; This example component demonstrates the following:
;; 1) Using shared styles, the :.headline and :.twirl classes, which are defined
;;    in browser.shared-styles.
;; 2) Using kushi's shorthand syntax via tokenized keyword
;;    :animation-name--x-axis-spinner
;; 3) Using dynamic values for color and animation duration.

(defn headline-layer
  [color duration]
  [:div
   (sx
    'headline-layer
    :.headline
    :.twirl
    :animation-name--x-axis-spinner
    [:animation-duration duration]
    [:color color])
   "Kushi"])


;; Next, we define a subcomponent for the sub-header.
;; This example `twirling-subheader` component demonstrates the following:

;; 1) Using a quoted symbol to create your own selector name,
;;    instead of default auto-generated selector.

;; 2) Using kushi's shorthand syntax via tokenized keywords.

;; 3) Tokenized keyword with css "alt list" shorthand
;;    :ff--FiraCodeRegular|monospace|sans-serif

;; 4) Using media queries - :sm:fs--14px

;; 5) Passing an attributes map (optional last arg to sx)

(defn twirling-subheader [s]
  [:div
   (sx 'kqs-twirling-subheader-wrapper
       :.twirl
       :.relative
       :ta--center
       :ff--FiraCodeRegular|monospace|sans-serif
       :fs--12px
       :sm:fs--14px
       :fw--800
       :c--white
       {:on-click #(prn "clicked!")})
   s])


;; Main component.
(defn main-view []
  ;; (js/console.clear)
  [:div
   (sx 'main-app-wrapper
       :ff--sys)
   [:div
    (sx :.flex-col-c
        :.absolute-fill
        :h--100%
        :ai--c )

    ;; In this div we are using both tokenized keywords,
    ;; and the 2-element tuple syntax.
    #_[:div
     (sx 'hero-wrapper
         :.flex-col-sb
         :ai--c
         :w--100%
         :h--200px
         :sm:h--375px
         :md:h--500px
         [:transform "translateY(calc(-100vh / 33))"])

     ;; The color tokens below are defined globally in the theme.cljc file,
     ;; which is specified in the :theme entry in your kushi.edn config file.
     [:div
      [headline-layer "var(--howlite-blue)" :12s]
      [headline-layer "var(--canary-yellow)" :3s]
      [headline-layer  "var(--deep-fuscsia)" :6s]]
     [twirling-subheader "kushi Ã— shadow-cljs quickstart"]]]

   #_[badges/links]

   [:div (sx 'stage
             :.flex-col-c
             :.absolute-fill
             :h--100%
             :ai--c 
             :$ns-side-offset--50px
             :$ew-side-offset--80px
             :$edge-offset--0)
    ;; [:div (sx :.debug-grid :$debug-grid-size--64px :w--100% :h--300px)]
    ;; [:div (sx :.debug-grid-8 :w--100% :h--300px)]
    ;; [:div (sx :.debug-grid-16 :w--100% :h--300px)]
    ;; [badges/north-edge]
    ;; [badges/north-side]
    ;; [badges/east-edge]
    ;; [badges/east-side]
    ;; [badges/south-edge]
    ;; [badges/south-side]
    ;; [badges/west-edge]
    ;; [badges/west-side]
    [badges/middle]
    ]])


;; Below is boilerplate code from
;; https://github.com/shadow-cljs/quickstart-browser

;; start is called by init and after code reloading finishes


(defclass lime-bg :bgc--lime)


(defonce active-intervals (r/atom []))


(defn pop-tip [children n instance-delay]
  (let [el     (j/get children n)
                enter  (domo/mouse-event! :mouseenter)
                leave  (domo/mouse-event! :mouseleave)
                append (partial append-fune!
                                {:arrow? true
                                 :tooltip-text "-----" #_(string/join " " (domo/random-emojis 3))
                                 :placement-kw (keyword (domo/data-attr el "kushi-ui-fune"))})]
            (.addEventListener el "mouseenter" append #js {:once true})
            (js/setTimeout 
             #(do (domo/dispatch-event! el enter)
                  (domo/add-class! el :lime-bg)
                  (js/setTimeout (fn [_]
                                   (.dispatchEvent el leave)
                                   (domo/remove-class! el :lime-bg))
                                 instance-delay))
             (* instance-delay n))))


(defn pop-tips-profile [sel]
  (let [children       (some->> sel
                                (domo/qs js/document)
                                .-children
                                js->clj)
        nchildren      (.-length children)
        instance-delay 200]
    {:children       children
     :nchildren      nchildren
     :instance-delay instance-delay
     :interval-delay (+ instance-delay (* instance-delay nchildren))}))


(defn pop-tip-interval! [f interval-delay]
  (swap! active-intervals
         conj
         (js/setInterval f interval-delay)))


(defn pop-tips [sel]
  (let [{:keys [children 
                nchildren 
                instance-delay
                interval-delay]} (pop-tips-profile sel)]
    (pop-tip-interval!
     (fn [_]
       (dotimes [n nchildren]
         (pop-tip children n instance-delay)))
     interval-delay)))


(defn tooltip-auto-hover []
  (let [sels [".n-edge-trg"  
              ".n-side-trg"  
              ".w-side-trg"  
              ".w-edge-trg"  
              ".middle-trg.absolute-centered"
              ".e-side-trg"  
              ".e-edge-trg"  
              ".s-edge-trg"  
              ".s-side-trg"]]
    (doseq [sel   sels
            :when (not (re-find #"edge" sel))]
      (pop-tips sel))))

(declare txty)
(declare txty-map)
(declare carpet)


(defn ^:dev/after-load start []
  (rdom/render [main-view]
               #_[carpet]
               (.getElementById js/document "app"))

  #_(??? #_{:coll-limit 50}
   
       )
  (js/setTimeout
   #_(fn [] (tooltip-auto-hover))
   #_(fn []
       (.addEventListener js/window
                          "mousemove"
                          (fn [e]
                            (println [[e.clientX e.clientY ]
                                      (domo/screen-quadrant-from-point e.clientX e.clientY )]) )))
   200))

(defn init []
  ;; init is called ONCE when the page loads
  ;; this is called in the index.html and must be exported
  ;; so it is available even in :advanced release builds
  (start))

;; this is called before any code is reloaded
(defn ^:dev/before-load stop []
  (doseq [id @active-intervals]
   (js/clearInterval id)))


;; This will inject the same stylesheet that kushi writes to disk into your
;; browser, during development builds. You may not need or want to do this
;; but if you are experiencing visual jankiness on reloads when devving,
;; this can help.
(when ^boolean js/goog.DEBUG
  (inject!))



(def txty 
  [:top-left-corner-outside     [:t 0 :l 0 -100 -100]
   :top-left-corner             [:t 0 :l 0 -50 -50]
   :top-left-corner-inside      [:t 0 :l 0 0 0]
   :top-left-outside            [:t 0 :l 0 0 -100]
   :top-left                    [:t 0 :l 0 0 -50]
   :top-outside                 [:t 0 :l 50 -50 -100]
   :top                         [:t 0 :l 50 -50 -50]
   :top-inside                  [:t 0 :l 50 -50 0]
   :top-right-outside           [:t 0 :r 0 0 -100]
   :top-right                   [:t 0 :r 0 0 -50]
   :top-right-corner-outside    [:t 0 :r 0 100 -100]
   :top-right-corner            [:t 0 :r 0 50 -50]
   :top-right-corner-inside     [:t 0 :r 0 0 0]
   :right-top-outside           [:t 0 :r 0 100 0]
   :right-top                   [:t 0 :r 0 50 0]
   :right-inside                [:t 50 :r 0 0 -50]
   :right                       [:t 50 :r 0 50 -50]
   :right-outside               [:t 50 :r 0 100 -50]
   :right-bottom-outside        [:b 0 :r 0 100 0]
   :right-bottom                [:b 0 :r 0 50 0]
   :bottom-right-corner-outside [:b 0 :r 0 100 100]
   :bottom-right-corner         [:b 0 :r 0 50 50]
   :bottom-right-corner-inside  [:b 0 :r 0 0 0]
   :bottom-right-outside        [:b 0 :r 0 0 100]
   :bottom-right                [:b 0 :r 0 0 50]
   :bottom-inside               [:b 0 :l 50 -50 0]
   :bottom                      [:b 0 :l 50 -50 50]
   :bottom-outside              [:b 0 :l 50 -50 100]
   :bottom-left-outside         [:b 0 :l 0 0 100]
   :bottom-left                 [:b 0 :l 0 0 50]
   :bottom-left-corner-outside  [:b 0 :l 0 -100 100]
   :bottom-left-corner          [:b 0 :l 0 -50 50]
   :bottom-left-corner-inside   [:b 0 :l 0 0 0]
   :left-bottom-outside         [:b 0 :l 0 -100 0]
   :left-bottom                 [:b 0 :l 0 -50 0]
   :left-inside                 [:t 50 :l 0  0 -50]
   :left                        [:t 50 :l 0 -50 -50]
   :left-outside                [:t 50 :l 0 -100 -50]
   :left-top-outside            [:t 0 :l 0 -100 0]
   :left-top                    [:t 0 :l 0 -50 0]])

(def txty-map 
  (apply hash-map txty))

(def tb :top)

(defn geometries [position]
  (into
   [:div (sx :.absolute-centered :.wireframe :w--500px :h--500px)]
   (println 
    (apply
     concat 
     (for [[k [tb tb-pct lr lr-pct tx ty]] (partition 2 txty)]
       (let [trbl     (-> k name (string/split #"-"))
             abbr     (string/join (map first trbl))
             outside? (->> k name (re-find #"outside"))
             inside?  (->> k name (re-find #"inside"))
             style    {:position  position
                       :top       (if (= tb :t) (str tb-pct "%") :unset)
                       :bottom    (if (= tb :b) (str tb-pct "%") :unset)
                       :left      (if (= lr :l) (str lr-pct "%") :unset)
                       :right     (if (= lr :r) (str lr-pct "%") :unset)
                       :translate (str tx "%" " " ty "%")}]
         [(keyword (str (name k) (when (= position :fixed) "-fixed"))) style]))))))

#_(geometries :fixed)

#_(defn carpet-test []
  (into
   [:div (sx :.absolute-centered :.wireframe :w--500px :h--500px)]
   (?pp 
    (apply
     concat 
     (for [[k [tb tb-pct lr lr-pct tx ty]] (partition 2 txty)]
       (let [trbl     (-> k name (string/split #"-"))
             abbr     (string/join (map first trbl))
             outside? (->> k name (re-find #"outside"))
             inside?  (->> k name (re-find #"inside"))
             style    {
                    ;;  :opacity    0.2
                    ;;  :background (cond outside? :blue inside? :orange :else :lime)
                    ;;  :width      :100px
                    ;;  :height     :100px
                       :position  :absolute
                       :top       (if (= tb :top) (str tb-pct "%") :unset)
                       :bottom    (if (= tb :bottom) (str tb-pct "%") :unset)
                       :left      (if (= lr :left) (str lr-pct "%") :unset)
                       :right     (if (= lr :right) (str lr-pct "%") :unset)
                       :translate (str tx "%" " " ty "%")}]
         [k style]
         #_[:div {:id    k
                  :style style}
            #_abbr]))))))

(defn carpet []
  (into
   [:div (sx :.absolute-centered :.wireframe :w--500px :h--500px)]
   (for [[k [tb tb-pct lr lr-pct tx ty]] (partition 2 txty)]
     (let [trbl     (-> k name (string/split #"-"))
           abbr     (string/join (map first trbl))
           outside? (->> k name (re-find #"outside"))
           inside?  (->> k name (re-find #"inside"))
           style    {:opacity    0.2
                     :background (cond outside? :blue inside? :orange :else :lime)
                     :width      :100px
                     :height     :100px
                    ;;  :position   :absolute
                    ;;  :top        (if (= tb :top) (str tb-pct "%") :unset)
                    ;;  :bottom     (if (= tb :bottom) (str tb-pct "%") :unset)
                    ;;  :left       (if (= lr :left) (str lr-pct "%") :unset)
                    ;;  :right      (if (= lr :right) (str lr-pct "%") :unset)
                    ;;  :translate  (str tx "%" " " ty "%")
                     }]
       [:div {:id    k
              :style style
              :class k}
        ]))))
